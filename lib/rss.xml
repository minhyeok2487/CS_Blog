<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[기술면접 준비]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>기술면접 준비</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 19 Aug 2024 01:24:09 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 19 Aug 2024 01:24:09 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[001. 자바의 Generic]]></title><description><![CDATA[ 
 <br><br>자바 제네릭(Generic)은 클래스나 메서드를 작성할 때 데이터 타입을 미리 지정하지 않고, 사용할 때 타입을 지정할 수 있게 해주는 기능입니다. 제네릭을 사용하면 코드 재사용성이 높아지고, 컴파일 시 타입 안전성을 확보할 수 있습니다.<br>이러한 제네릭은 자료구조와 연관되어 있습니다. 자바의 List, Set, Map 등의 자료구조 클래스는 제네릭을 활용하여 다양한 타입의 데이터를 다룰 수 있도록 설계되어있습니다.<br><br><br>Set은 중복되지 않은 요소들의 집합을 나타내는 자료구조입니다. 여기에 제네릭을 적용하면 Set에 저장되는 요소의 타입을 명확하게 지정할 수 있습니다. 즉, 특정 타입의 객체만 저장하도록 제한할 수 있습니다.<br>
예를들어, A라는 변수에 String만 저장되는 Set 자료구조를 만들고 싶다면<br>
Set&lt;String&gt; A 라는 형식으로 생성하는 식 입니다.<br><br><br>Object를 사용하면 데이터를 꺼낼 때 Object 타입으로 꺼내지게 되고, 추가적인 작업을 위해서 형 변환이 필수 입니다. 여기서 발생되는 문제로, 만약 추가적인 작업이 Integer 타입으로 짜여져있을때 값이 String 타입이면 에러가 발생합니다.<br>
따라서, 추가적인 형변환 없이 명확하게 원하는 타입만 저장하기 위해 Generic은 필수 입니다.<br><br><br>제네릭 와일드카드는 제네릭 타입에서 특정 타입을 명시하지 않고, 어떤 타입이 올 수 있는지에 대한 제약을 표현하는 방법입니다. 마치 정규 표현식에서 와일드카드 문자(*)가 어떤 문자든지 대표하는 것처럼, 제네릭에서도 와일드카드(?)가 다양한 타입을 나타냅니다.<br>
와일드카드의 종류로는 비제한 와일드카드, 상한 제한 와일드카드, 하한 제한 와일드카드 가 있습니다.]]></description><link>기술면접 준비/001. 자바의 Generic.html</link><guid isPermaLink="false">기술면접 준비/001. 자바의 Generic.md</guid><pubDate>Mon, 19 Aug 2024 01:19:30 GMT</pubDate></item><item><title><![CDATA[002. Garbage Collection]]></title><description><![CDATA[ 
 <br><br>프로그래밍에서 객체나 변수를 생성하면, 이들은 메모리를 점유하게 됩니다. 하지만 더 이상 사용되지 않거나 참조되지 않는 객체가 남아 있다면, 그들이 차지하는 메모리는 비효율적으로 낭비됩니다. 이러한 메모리 누수를 방지하기 위해 Garbage Collection이 필요합니다.<br>Garbage Collection은 프로그래밍에서 더 이상 사용되지 않는 메모리를 자동으로 회수하는 메모리 관리 기법입니다. 주요 방식에는 참조가 0인 객체를 회수하는 참조 카운팅(Reference Counting), 사용 중인 객체를 마크하고 나머지를 회수하는 마크 앤 스위프(Mark and Sweep), 활성 객체를 다른 메모리 영역으로 복사하는 복사 수집(Copying Collection)이 있습니다. 이를 통해 메모리 누수를 방지하고 메모리 관리를 자동화하여 개발자의 부담을 줄여줍니다.<br><br><br>마크 앤 스위프는 마크(Mark) 단계와 스위프(Sweep) 단계가 있습니다.<br>Mark 단계는 프로그램이 사용하는 모든 객체를 탐색하고, 사용 중인 객체에 "마크"를 표시합니다. 이 과정에서 참조 그래프를 따라가며 접근 가능한 객체들을 식별합니다.<br>Sweep 단계는 마크되지 않은 객체는 더 이상 참조되지 않거나 사용되지 않는 것으로 간주됩니다. 이 객체들의 메모리를 해제하여, 프로그램이 다른 목적으로 사용할 수 있도록 합니다.<br>이 방식의 장점은 순환 참조 문제를 해결할 수 있다는 것입니다. 왜냐하면 사용 중인 객체만을 식별하여 회수 대상에서 제외하기 때문입니다. 그러나 Mark 단계에서 모든 객체를 탐색해야 하므로 성능에 영향을 줄 수 있습니다.<br><br><br>자바(Java)에서는 Garbage Collection이 자동으로 수행되며, 메모리 관리의 핵심 요소로 작동합니다. 자바 프로그램에서 객체를 생성하면, 그 객체는 힙(Heap) 메모리에 저장되며, 더 이상 사용되지 않거나 참조되지 않는 객체는 Garbage Collector에 의해 자동으로 회수됩니다.<br>자바의 가비지 콜렉션 종류 중 Major GC, Full GC의 경우 앞서 설명한 마크 앤 스위프 방식으로 메모리에서 사용 중인 객체를 탐색하여 마크한 후, 사용되지 않는 객체를 회수합니다. <br><br><br>힙 메모리는 Young Generation, Old Generation, Permanent Generation으로 나눕니다.<br>
<br>Young Generation: 새로 생성된 객체가 할당되며, 주로 짧은 생명 주기를 가집니다. 여기에서 살아남은 객체는 Old Generation으로 이동합니다.
<br>Old Generation: Young Generation에서 살아남은 객체들이 오래 사용되는 객체로 간주되며, 여기로 이동합니다.
<br>Permanent Generation: 클래스와 메서드 메타데이터가 저장됩니다(현재는 메타스페이스로 대체됨).
]]></description><link>기술면접 준비/002. Garbage Collection.html</link><guid isPermaLink="false">기술면접 준비/002. Garbage Collection.md</guid><pubDate>Mon, 19 Aug 2024 01:19:09 GMT</pubDate></item><item><title><![CDATA[003. Spring 동작 방식]]></title><description><![CDATA[ 
 <br><br>먼저 웹 브라우저 같은 클라이언트가 서버로 HTTP 요청을 보냅니다.<br>스프링 웹 애플리케이션은 DispatcherServlet이 가장 먼저 요청을 받습니다. 이 서블릿은 스프링 MVC의 프론트 컨트롤러 역할을 하며, 들어오는 요청을 적절한 행들러로 라우팅하는 역할을 합니다.<br>DispatcherServlet은 요청된 URL과 매핑된 컨트롤러 메서드를 찾기 위해 여러 HandlerMapping 인터페이스 구현체를 순차적으로 조회합니다. 이 과정에서 요청 경로, HTTP 메소드 등에 따라 어떤 컨트롤러의 어떤 메소드가 처리할지 결정됩니다.<br>그 뒤 HandlerAdapter가 실제로 요청을 처리하는 컨트롤러 메소드를 호출 후, 클라이언트로부터 받은 요청 데이터를 처리하고, DispatcherServlet이 생성된 결과를 클라이언트에게 반환합니다. <br><br><br>필터는 서블릿 스펙에 정의된 기능으로, 주로 요청이 DispatcherServlet에 도달하기 전에 요청을 가로채거나 변경할 때 사용됩니다. 필터는 스프링 컨텍스트 외부에서 동작하며, 스프링 프레임워크에 의존하지 않습니다. 예를 들어 로깅/모니터링 등 요청과 응답에 대한 로그를 남기거나, 요청에 대한 인증 또는 인과와 관련된 작업을 사전 처리할 때 필터를 사용합니다.<br>인터셉터는 스프링 MVC가 제공하는 기능으로, HandlerMapping이 적절한 컨트롤러를 찾은 후 컨트롤러 메서드가 실행되기 전에, 또는 응답을 생성한 후에 특정 작업을 수행할 때 사용됩니다. 인터셉터는 스프링 컨텍스트 내에서 동작하며, 스프링 빈에 접근할 수 있습니다. 예를들어, 여러 컨트롤러 메서드에서 공통적으로 필요한 전처리 또는 후처리 로직을 구현하거나, 컨트롤러 메서드 실행 전후로 필요한 데이터 가공이나 로직을 수행할 때 인터셉터를 사용합니다.<br><br><br>AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍) 는 애플리케이션의 핵심 비즈니스 로직과는 별개의 횡단 관심사(cross-cutting concerns)를 모듈화하여 관리할 수 있는 프로그래밍 패러다임입니다.<br>
스프링에서 AOP는 주로 다음과 같은 개념들로 구성됩니다.<br>
<br>Aspect: 횡단 관심사를 모듈화한 것, 즉 AOP의 주요 단위입니다.
<br>JoinPoint: 어드바이스(Advice)가 적용될 수 있는 지점, 즉 메서드 호출, 객체 생성 등입니다.
<br>Advice: 특정 JoinPoint에서 실행되는 코드, 로깅, 트랜잭션 관리 등의 구체적인 작업을 수행합니다.
<br>Pointcut: JoinPoint를 필터링하여 특정 조건에 따라 Advice를 적용할 위치를 정의합니다.
]]></description><link>기술면접 준비/003. Spring 동작 방식.html</link><guid isPermaLink="false">기술면접 준비/003. Spring 동작 방식.md</guid><pubDate>Mon, 19 Aug 2024 01:19:12 GMT</pubDate></item></channel></rss>